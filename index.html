<html>
    <body>
        <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="GLModel.js"></script>
        <script type="text/javascript" src="GLSphere.js"></script>
        <script type="text/javascript" src="GLPyramid.js"></script>
        <script type="text/javascript" src="GLCube.js"></script>
        <link rel="stylesheet" type="text/css" href="GL.css" />


        <script id="shader-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;
            attribute vec4 aVertexColor;


            uniform mat4 uMVMatrix;
            uniform mat4 uCamMatrix;
            uniform mat4 uPMatrix;
            uniform mat3 uNMatrix; // just inverse of mv transforms
            uniform mat3 uNCamMatrix; // inverse of cam transforms

            uniform bool uUseFlashlight;
            uniform bool uUseLighting;

            varying vec2 vTextureCoord;
            varying vec4 vColor;
            varying vec3 vLightWeighting;


            void main(void) {
                gl_Position = uPMatrix * uCamMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vTextureCoord = aTextureCoord;

                //top light
                vec3 topLightDirection = vec3(0, 1, 0);

                //front light
                vec3 camLightDirection = vec3(0, 0, 1);

                //vLightWeighting = vec3(1, 1, 1);
                //vLightWeighting = aVertexPosition;
                vec3 transformedTopNormal = normalize(uNMatrix * aVertexNormal);
                vec3 transformedCamNormal = normalize(uNCamMatrix * uNMatrix * aVertexNormal);
                //vec3 transformedLight = lightDirection;

                float topLightWeighting = max(dot(transformedTopNormal, topLightDirection), 0.0);
                float camLightWeighting = max(dot(transformedCamNormal, camLightDirection), 0.0);

                vLightWeighting = vec3(0.2, 0.2, 0.2) + vec3(0.4, 0.4, 0.4) * topLightWeighting;
                if(uUseFlashlight) {
                    vLightWeighting = vLightWeighting + vec3(0.4, 0.4, 0.4) * camLightWeighting;
                }
                if(!uUseLighting) {
                    vLightWeighting = vec3(1.0, 1.0, 1.0);
                }


                vColor = aVertexColor;
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTextureCoord;
            varying vec4 vColor;
            varying vec3 vLightWeighting;

            uniform sampler2D uSampler;
            uniform bool uUseTextures;
            uniform float uTextureAlpha;

            void main(void) {
                if(uUseTextures) {
                    vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                    
                    //experiment with interpolation
                    //textureColor = vec4(vTextureCoord.s, vTextureCoord.t, 1, 1);
                    
                    gl_FragColor = vec4(textureColor.rgb*vLightWeighting, textureColor.a);//*uTextureAlpha + vColor*(1.0-uTextureAlpha);

                    //vec4 realColor = textureColor*uTextureAlpha + vColor*(1.0-uTextureAlpha);
                    //gl_FragColor = vec4(realColor.rgb*uTextureAlpha, realColor.a);

                } else {
                    gl_FragColor = vec4(vColor.rgb*vLightWeighting, vColor.a);
                }
            }
        </script>

        <script type="text/javascript" src="main.js"></script>

        <script type="text/javascript">

            var canvas;

            function webGLStart() {
                canvas = document.getElementById("canvas");

                canvas.onmousemove = function (e) {
                    var rect = canvas.getBoundingClientRect();
                    mouseX = (e.clientX - rect.left) / canvas.width - 0.5;
                    mouseY = (e.clientY - rect.top) / canvas.height - 0.5;
                    GLPlayer.rotation.horizontal = (mouseX*Math.PI)*2;
                    GLPlayer.rotation.vertical = (mouseY*Math.PI);
                };

                var keys = [];
                window.onkeydown = function(e) {
                    /*if(!keys[70] && e.keyCode == 70) {
                        GLPlayer.flashlight = !GLPlayer.flashlight;
                        gl.uniform1i(shaderProgram.useFlashlightUniform, flashlight);
                    }*/

                    if((!keys[32] && e.keyCode == 32) && GLPlayer.position.z == 0) {
                        GLPlayer.velocity.z = 1;
                    }
                    keys[e.keyCode] = true;
                };
                window.onkeyup = function(e) {
                    keys[e.keyCode] = false;
                };

                var speed = 0.1;
                var friction = 0.7;
                setInterval(function(){
                    if(keys[87] || keys[38]) { // w
                        GLPlayer.velocity.x -= Math.sin(GLPlayer.rotation.horizontal)*speed;
                        GLPlayer.velocity.y += Math.cos(GLPlayer.rotation.horizontal)*speed;
                    }
                    if(keys[83] || keys[40]) { // s
                        GLPlayer.velocity.x += Math.sin(GLPlayer.rotation.horizontal)*speed;
                        GLPlayer.velocity.y -= Math.cos(GLPlayer.rotation.horizontal)*speed;
                    }
                    if(keys[65] || keys[37]) { // a
                        GLPlayer.velocity.x += Math.cos(GLPlayer.rotation.horizontal)*speed;
                        GLPlayer.velocity.y += Math.sin(GLPlayer.rotation.horizontal)*speed;
                    }
                    if(keys[68] || keys[39]) { // d
                        GLPlayer.velocity.x -= Math.cos(GLPlayer.rotation.horizontal)*speed;
                        GLPlayer.velocity.y -= Math.sin(GLPlayer.rotation.horizontal)*speed;
                    }

                    GLPlayer.position.x += GLPlayer.velocity.x;
                    GLPlayer.position.y += GLPlayer.velocity.y;


                    GLPlayer.velocity.x *= friction;
                    GLPlayer.velocity.y *= friction;

                    GLPlayer.position.z += GLPlayer.velocity.z;
                    if(GLPlayer.position.z > 0) {
                        GLPlayer.velocity.z -= 0.1;
                    } else {
                        GLPlayer.velocity.z = 0;
                        GLPlayer.position.z = 0;
                    }

                    thingerRotation += Math.PI/40.0;
                    if(thingerRotation > Math.PI*2) {
                        thingerRotation -= Math.PI*2;
                    }

                    drawScene();
                }, 25);

                initGL(canvas);

                

                
                //gl.disable(gl.DEPTH_TEST);
                //gl.enable(gl.BLEND);
                //gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

                //flashlight = true;
                //gl.uniform1i(shaderProgram.useFlashlightUniform, flashlight);

                //drawScene();


            }

            var mouseX = 0.0;
            var mouseY = 0.0;


        </script>
        <canvas id="canvas" style="border: none;" width="800" height="500"></canvas>
        <script type="text/javascript">
            webGLStart();
        </script>
    </body>

</html>

